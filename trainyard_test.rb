
require "test/unit"
require_relative "trainyard.rb"
require_relative "trainyard_heuristic.rb"
require_relative "trainyard_search.rb"

class DataStructureTest < Test::Unit::TestCase
  def test_yards
    assert_equal(4, Yard.all_yards.length)
    
    Yard.all_yards.each{ |yard| 
      assert_not_nil(yard)
      moves = yard.all_moves
      assert_equal(yard.length * 2, moves.length)
      # puts moves.to_s
    }
    
    assert_equal(6, Yard.yard1.list_tracks.size)
    assert_equal(5, Yard.yard2.list_tracks.size)
    assert_equal(3, Yard.yard3.list_tracks.size)
    
    puts "Track list: #{Yard.yard2.list_tracks}"
  end
  
  def test_states
    # test generation and printing of the hash
    initial_state1 = State[ [ [:t1, [:engine]], [:t2, [:e]], [:t4, [:b, :c, :a]], [:t6, [:d]] ] ]
    puts "Initial :t1 #{initial_state1[:t1]}"
    puts "Test Initial 1: " + initial_state1.to_s
    assert_equal(4, initial_state1.length)
    goal_state1 = State[[ [:t1, [:engine, :a, :b, :c, :d, :e]] ]]
    puts "Test Goal 1:    " + goal_state1.to_s
    assert_equal(1, goal_state1.length)
    
    assert_equal([], goal_state1.cars_on_track(:t2))
    assert_equal([:engine, :a, :b, :c, :d, :e], goal_state1.cars_on_track(:t1))
    
    # updating the hash
    updated1 = initial_state1.update_track(:t1, [])
    assert_equal(initial_state1.size - 1, updated1.size, "Updated1: #{updated1}")
    
    updated2 = initial_state1.update_track(:t1, [:engine, :a, :b])
    assert_equal(initial_state1.size, updated2.size)
    
    updated3 = initial_state1.update_track(:t7, [:engine, :a, :b])
    assert_equal(initial_state1.size + 1, updated3.size)
    
    result_state1 = initial_state1.apply_move([:right, :t1, :t4])
    assert_equal({:t2=>[:e], :t4=>[:engine, :b, :c, :a], :t6=>[:d]}, result_state1)

    result_state1 = initial_state1.apply_move([:left, :t4, :t1])
    assert_equal({:t1=>[:engine, :b], :t2=>[:e], :t4=>[:c, :a], :t6=>[:d]}, result_state1)
    
    result_state1 = initial_state1.apply_move([:right, :t1, :t5])
    assert_equal({:t2=>[:e], :t4=>[:b, :c, :a], :t6=>[:d], :t5=>[:engine]}, result_state1)
    
    result_state1 = initial_state1.apply_move([:left, :t2, :t1])
    assert_equal({:t1=>[:engine, :e], :t4=>[:b, :c, :a], :t6=>[:d]}, result_state1)
    
    initial_state2 = State[[[:t1, [:engine]], [:t2, [:e]], [:t4, [:b, :c, :a]], [:t6, [:d]]]]
    initial_state2.apply_move!([:right, :t1, :t4])
    assert_equal({:t2=>[:e], :t4=>[:engine, :b, :c, :a], :t6=>[:d]}, initial_state2)
  end
  
  def test_cars_on_track
    state1 = Problem.problem1.state
    assert_equal([], state1.cars_on_track(:t10))
    assert_equal([:engine], state1.cars_on_track(:t1))
  
  end
  
  def test_states_reverse_move  
    # reverse_move tests
    initial_state1 = State[[[:t1, [:engine]], [:t2, [:e]], [:t4, [:b, :c, :a]], [:t6, [:d]]]]
    reverse_state_test1 = initial_state1.apply_move([:left, :t2, :t1])
    reverse_state_test2 = reverse_state_test1.reverse_move([:left, :t2, :t1])
    assert_equal(initial_state1, reverse_state_test2)
    
    problem1 = Problem.problem1
    possibles1 = possible_moves(problem1.yard(), problem1.state())
    possibles1.each{ |move|
      assert_equal(problem1.state, 
        problem1.state.apply_move(move).reverse_move(move)) }
        
    possibles1.each{ |move|
      assert_equal(problem1.state, 
        problem1.state.apply_move!(move).reverse_move!(move)) }
    
  end
  
  def test_states_already_seen?
    problem1 = Problem.problem1
    first_sstate = Solution_State.new(problem1.state, [])
    assert(first_sstate.already_seen?(problem1.state))
    
    problem4 = Problem.problem4
    solved_sstate = Trainyard_Search.depth_limited_search(problem4, 4)
    
    # assert that we've already seen the final state
    assert(solved_sstate.already_seen?(problem4.state))
    # run back through the move list and assert that we've seen 
    # all the states generated by all the moves
    solved_sstate.moves.inject(solved_sstate.state){ |reversing_state, move|
      assert(solved_sstate.already_seen?(reversing_state.reverse_move!(move)))
      reversing_state
    }
    
  end
  
  def test_equal_astar_states
    problem = Problem.problem3
    fringe_state = Astar_Solution_State.new(
      Solution_State.new(problem.state, []), 3)
    other_fringe_state = Astar_Solution_State.new(
      Solution_State.new(problem.state.clone, []), 3)
    other_fringe_state2 = Astar_Solution_State.new(
      Solution_State.new(Problem.problem1.state, []), 3)
    other_fringe_state_clone = Astar_Solution_State.new(
      Solution_State.new(problem.state.clone, []), 3)
    assert(fringe_state.equal_astar_states(other_fringe_state))
    assert(fringe_state.equal_astar_states(other_fringe_state_clone))
    assert(false == fringe_state.equal_astar_states(other_fringe_state2))
  end
  
  def test_astar_spaceship
    problem = Problem.problem3
    astarf0 = Astar_Solution_State.new(
      Solution_State.new(problem.state, []), 0)
    astarf0clone = Astar_Solution_State.new(
      Solution_State.new(problem.state.clone, []), 0)
    astarf1 = Astar_Solution_State.new(
      Solution_State.new(problem.state.clone, []), 1)
      
    assert(astarf0 == astarf0)
    assert(astarf0 == astarf0clone)
    assert(astarf0 < astarf1)
    assert(astarf1 > astarf0)
    sorted = [astarf0, astarf1].sort
    assert_equal(0, sorted.first.fvalue)
    puts "Sorted: #{sorted}"
    
  end
  
  def test_astar_expand
    problem = Problem.problem3
    astarf0 = Astar_Solution_State.new(
      Solution_State.new(problem.state, []), 0)
    
    h_curried = Proc.new {|state| NotOnGoalCount.calculate_fvalue(state, problem.goal, problem.yard) }
    
    expanded_states = astarf0.expand_solution(problem.yard, h_curried)
    assert_equal(4, expanded_states.length)
    expanded_states2 = expanded_states.first.expand_solution(problem.yard, h_curried)
    assert_equal(2, expanded_states2.length)
    
    puts "Expanded_states2: #{expanded_states2}"
  end
end

class UtilitiesTest < Test::Unit::TestCase
  def test_illegal_move?
    problem1 = Problem.problem1
    # [:t1, :t2], [:t1, :t3], [:t3, :t5], [:t4, :t5], [:t2, :t6], [:t5, :t6]
    # {t1, [engine]}, {t2, [e]}, {t4, [b, c, a]}, {t6, [d]}
    
    problem3 = Problem.problem3
    # yard [:t1, :t2], [:t1, :t3]
    # [:t1, [:engine], :t2, [:a], :t3, [:b]]
    
    #bad inputs
    assert( illegal_move?(1, problem3.yard(), problem3.state()))
    assert( illegal_move?([], problem3.yard(), problem3.state()))
    assert( illegal_move?(:a, problem3.yard(), problem3.state()))
    # track exists
    assert( illegal_move?([:left, :t3, :t2], problem3.yard(), problem3.state()))
    assert( illegal_move?([:right, :t3, :t2], problem3.yard(), problem3.state()))
    
    # track is not empty
    assert( illegal_move?([:left, :t3, :t2], problem3.yard(), State[[:t2, [:thing1]]]))
    assert( illegal_move?([:right, :t3, :t2], problem3.yard(), State[[:t2, [:thing1]]]))
    
    # tracks don't have an engine
    assert( illegal_move?([:left, :t2, :t6], problem1.yard(), problem1.state()) )
    assert( illegal_move?([:right, :t2, :t6], problem1.yard(), problem1.state()) )
    assert( illegal_move?([:left, :t3, :t5], problem1.yard(), problem1.state()) )
    assert( illegal_move?([:right, :t3, :t5], problem1.yard(), problem1.state()) )
    assert( illegal_move?([:left, :t5, :t6], problem1.yard(), problem1.state()) )
    assert( illegal_move?([:right, :t5, :t6], problem1.yard(), problem1.state()) )
    
    # legal moves
    assert( (not illegal_move?([:left, :t2, :t1], problem3.yard(), problem3.state())) )
    assert( (not illegal_move?([:right, :t1, :t2], problem3.yard(), problem3.state())) )
    
    assert( (not illegal_move?([:right, :t1, :t3], problem1.yard(), problem1.state())) )
    assert( (not illegal_move?([:right, :t1, :t2], problem1.yard(), problem1.state())) )
    assert( (not illegal_move?([:left, :t3, :t1], problem1.yard(),  State[:t1, [:a], :t2, [:b], :t3, [:engine]] ) )) 
    assert( (not illegal_move?([:left, :t3, :t1], problem1.yard(),  State[:t2, [:b], :t3, [:engine]] ) )) 
    
    collection = Yard.yard3.all_moves.collect{ |move|
      illegal_move?(move, problem3.yard(), problem3.state())
    }   
    assert( (not collection.any?) )
    #print "Test print", collection.to_s
  end
  
  def test_possible_moves
    problem1 = Problem.problem1
    possibles1 = possible_moves(problem1.yard(), problem1.state())
    possibles2 = possible_moves(problem1.yard(), problem1.goal())
    
    assert_equal(3, possibles1.length)
    assert_equal(2, possibles2.length)
    
  end
  
  def test_expand
    [Problem.problem1, Problem.problem2, Problem.problem3, 
      Problem.problem4, Problem.problem5].each { |problem|
      expand(problem.yard, problem.state) }
  end
  
end

class SearchTest < Test::Unit::TestCase
  def test_depth_limited_search
    # goal state returns immediately
    solved_problem = Problem.new(Yard.yard1, 
      State[:t1, [:engine, :a, :b, :c, :d, :e]] ,
      State[:t1, [:engine, :a, :b, :c, :d, :e]] ) 
    result1 = Trainyard_Search.depth_limited_search(solved_problem, 0)
    assert(result1.is_a?(Solution_State))
    
    problem3 = Problem.problem3
    problem4 = Problem.problem4
    # depth 0 returns immediately
    result2 = Trainyard_Search.depth_limited_search(problem3, 0)
    assert_equal(:failed_limit_reached, result2)
    
    result3 = Trainyard_Search.depth_limited_search(problem3, 1)
    assert_equal(:failed_out_of_moves, result3)
    
    result4 = Trainyard_Search.depth_limited_search(problem3, 2)
    assert(result4.is_a?(Solution_State))
    assert_equal(2, result4.moves.size)
    puts result4.to_s
    
    result5 = Trainyard_Search.depth_limited_search(problem4, 4)
    assert(result5.is_a?(Solution_State))
    assert_equal(4, result5.moves.size)
    puts result5.to_s
    
  end
  
  def test_iterative_deepening_search
    
    [Problem.problem3, Problem.problem4, Problem.problem5].each { |problem|
      puts "Testing IDS on problem: #{problem.to_s}"
      result = Trainyard_Search.iterative_deepening_search(problem)
      Trainyard_Search.print_solution(problem, result)
      assert_equal(problem.goal, result.state)
    }
  end
end

class Heuristic_Test < Test::Unit::TestCase
  def test_not_on_goal_count
    problem3 = Problem.problem3
    count = NotOnGoalCount.calculate_fvalue(problem3.state, problem3.goal, problem3.yard)
    assert_equal(2, count)
    count = NotOnGoalCount.calculate_fvalue(problem3.goal, problem3.state, problem3.yard)
    assert_equal(2, count)
    
    Problem.all_problems.each{|problem|
      assert_equal( NotOnGoalCount.calculate_fvalue(problem.state, problem.goal, problem.yard),
        NotOnGoalCount.calculate_fvalue(problem.goal, problem.state, problem.yard) )
    }

    sstate = Solution_State.new(
      problem3.state, [])
    astarstate = Astar_Solution_State.new(sstate, count)
    assert_not_nil(astarstate)
    
  end
end
  
class Astar_Search_Test < Test::Unit::TestCase
  def test_fast_search_astar

    [Problem.problem5, Problem.problem3, Problem.problem4].each { |problem|
      puts "Testing astar search on problem: #{problem.to_s}"
      result = Trainyard_Search_Astar.search_astar(problem, NotOnGoalCount)
      puts "test result: #{result}"
      assert(result.instance_of?(Astar_Solution_State))
      assert_equal(problem.goal, result.sstate.state)
      Trainyard_Search_Astar.print_astar_solution(problem, result)        
    }
  end

  def test_astar_search_step
    problem = Problem.problem3
    h_curried = Proc.new {|state| NotOnGoalCount.calculate_fvalue(state, problem.goal, problem.yard) }

    assert_equal(:failed_out_of_moves,
      Trainyard_Search_Astar.search_astar_step(problem, 
        [], [], h_curried))

    solved_fringe = [Astar_Solution_State.new(Solution_State.new(problem.goal, []), 0)]
    result1 = Trainyard_Search_Astar.search_astar_step(problem, 
        solved_fringe, [], h_curried)
    assert(result1.instance_of?(Astar_Solution_State))
  end
end
